// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BFATLAS_BFGAME_H_
#define FLATBUFFERS_GENERATED_BFATLAS_BFGAME_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace BFGame {

struct Texture;
struct TextureBuilder;

struct Atlas;
struct AtlasBuilder;

struct Texture FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_DEBUG_NAME = 6,
    VT_ATLAS_X = 8,
    VT_ATLAS_Y = 10,
    VT_SIZE_X = 12,
    VT_SIZE_Y = 14
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool KeyCompareLessThan(const Texture * const o) const {
    return id() < o->id();
  }
  int KeyCompareWithValue(uint32_t _id) const {
    return static_cast<int>(id() > _id) - static_cast<int>(id() < _id);
  }
  const ::flatbuffers::String *debug_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DEBUG_NAME);
  }
  uint32_t atlas_x() const {
    return GetField<uint32_t>(VT_ATLAS_X, 0);
  }
  uint32_t atlas_y() const {
    return GetField<uint32_t>(VT_ATLAS_Y, 0);
  }
  uint32_t size_x() const {
    return GetField<uint32_t>(VT_SIZE_X, 0);
  }
  uint32_t size_y() const {
    return GetField<uint32_t>(VT_SIZE_Y, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID, 4) &&
           VerifyOffset(verifier, VT_DEBUG_NAME) &&
           verifier.VerifyString(debug_name()) &&
           VerifyField<uint32_t>(verifier, VT_ATLAS_X, 4) &&
           VerifyField<uint32_t>(verifier, VT_ATLAS_Y, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_X, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE_Y, 4) &&
           verifier.EndTable();
  }
};

struct TextureBuilder {
  typedef Texture Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Texture::VT_ID, id, 0);
  }
  void add_debug_name(::flatbuffers::Offset<::flatbuffers::String> debug_name) {
    fbb_.AddOffset(Texture::VT_DEBUG_NAME, debug_name);
  }
  void add_atlas_x(uint32_t atlas_x) {
    fbb_.AddElement<uint32_t>(Texture::VT_ATLAS_X, atlas_x, 0);
  }
  void add_atlas_y(uint32_t atlas_y) {
    fbb_.AddElement<uint32_t>(Texture::VT_ATLAS_Y, atlas_y, 0);
  }
  void add_size_x(uint32_t size_x) {
    fbb_.AddElement<uint32_t>(Texture::VT_SIZE_X, size_x, 0);
  }
  void add_size_y(uint32_t size_y) {
    fbb_.AddElement<uint32_t>(Texture::VT_SIZE_Y, size_y, 0);
  }
  explicit TextureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Texture>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Texture> CreateTexture(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> debug_name = 0,
    uint32_t atlas_x = 0,
    uint32_t atlas_y = 0,
    uint32_t size_x = 0,
    uint32_t size_y = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_size_y(size_y);
  builder_.add_size_x(size_x);
  builder_.add_atlas_y(atlas_y);
  builder_.add_atlas_x(atlas_x);
  builder_.add_debug_name(debug_name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Texture> CreateTextureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *debug_name = nullptr,
    uint32_t atlas_x = 0,
    uint32_t atlas_y = 0,
    uint32_t size_x = 0,
    uint32_t size_y = 0) {
  auto debug_name__ = debug_name ? _fbb.CreateString(debug_name) : 0;
  return BFGame::CreateTexture(
      _fbb,
      id,
      debug_name__,
      atlas_x,
      atlas_y,
      size_x,
      size_y);
}

struct Atlas FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AtlasBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXTURES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<BFGame::Texture>> *textures() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<BFGame::Texture>> *>(VT_TEXTURES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.VerifyVector(textures()) &&
           verifier.VerifyVectorOfTables(textures()) &&
           verifier.EndTable();
  }
};

struct AtlasBuilder {
  typedef Atlas Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_textures(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BFGame::Texture>>> textures) {
    fbb_.AddOffset(Atlas::VT_TEXTURES, textures);
  }
  explicit AtlasBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Atlas> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Atlas>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Atlas> CreateAtlas(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<BFGame::Texture>>> textures = 0) {
  AtlasBuilder builder_(_fbb);
  builder_.add_textures(textures);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Atlas> CreateAtlasDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    std::vector<::flatbuffers::Offset<BFGame::Texture>> *textures = nullptr) {
  auto textures__ = textures ? _fbb.CreateVectorOfSortedTables<BFGame::Texture>(textures) : 0;
  return BFGame::CreateAtlas(
      _fbb,
      textures__);
}

inline const BFGame::Atlas *GetAtlas(const void *buf) {
  return ::flatbuffers::GetRoot<BFGame::Atlas>(buf);
}

inline const BFGame::Atlas *GetSizePrefixedAtlas(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<BFGame::Atlas>(buf);
}

inline const char *AtlasIdentifier() {
  return "GLIB";
}

inline bool AtlasBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AtlasIdentifier());
}

inline bool SizePrefixedAtlasBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AtlasIdentifier(), true);
}

inline bool VerifyAtlasBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<BFGame::Atlas>(AtlasIdentifier());
}

inline bool VerifySizePrefixedAtlasBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<BFGame::Atlas>(AtlasIdentifier());
}

inline void FinishAtlasBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BFGame::Atlas> root) {
  fbb.Finish(root, AtlasIdentifier());
}

inline void FinishSizePrefixedAtlasBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<BFGame::Atlas> root) {
  fbb.FinishSizePrefixed(root, AtlasIdentifier());
}

}  // namespace BFGame

#endif  // FLATBUFFERS_GENERATED_BFATLAS_BFGAME_H_
